# Vue 易忘知识点

## 数据驱动

传统的 web 应用模式：

响应用户操作 -> 发送数据到后台 -> 获取数据更新到 web 界面

数据驱动模式：

响应用户操作 -> 发送数据到后台 -> 获取数据更新到 viewModel  -> viewModel 跟 web 界面双向绑定，viewModel 中的数据更新 view 界面跟着更新

## MVVM

![495px-MVVMPattern](.\imgs\495px-MVVMPattern.png)

MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种软件[架构模式](https://zh.wikipedia.org/wiki/架构模式)。

Model 层代表数据模型，可以在 Model 中定义数据修改和操作的业务逻辑，比如数据的增删改查。

View 代表视图层，它负责将数据模型转化成 UI 展现出来。

ViewModel 是前端业务逻辑层（一切 js 可是业务逻辑，比如表单按钮的提交，自定义事件的注册和处理逻辑），负责监控两边的数据，即是一个同步 View 和 Model 的对象。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，view 和 Model 与 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。

MVVM模式，视图层和数据层的双向绑定，让我们无需再去关心 DOM 操作的事情，更过的精力放在数据和业务逻辑上去。

## 优点

1. 渐进式，轻量级的框架，简单易上手的 api

2. 数据驱动，数据双向绑定

3. 高性能，功能强大

4. 组件化

5. 指令化

## 核心功能

- Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统

## 组件化

-  是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。几乎任意类型的应用界面都可以抽象为一个组件树

- 把一个功能做成组件，这个组件就是独立的。需要多个组件那就引用多次，每个组件之间互相没有关系

## 响应式

- vue 是响应式的，意思是说，当一个数据发生变化，那么网页中所有用到该数据的地方都会自动更新。

## 实例生命周期

- created --- 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载，$el 还不可用。需要初始化处理一些数据时会比较有用----还未挂载
- mounted --- el 挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始 。相当于$(document).ready()---刚刚挂载 
- beforeDestroy --- 实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等

[生命周期图示](https://cn.vuejs.org/images/lifecycle.png)

## 过滤器

 Vue 支持在 {{}} 文本插值的尾部添加一小管道符 “ | ” 对数据进行过滤，经常用于格式化文本，比如字母全部大写、货币千位使用逗号分隔等。过滤的规则是自定义的， 通过给 Vue 实例添加选项 filters 来设置。比如`{{ value| filter1 |filter2}}`。 `{{value| formatDate(66,99)}}` 中的第一个和第二个参数，分别对应过滤器的第二个和第三个参数

注意：`{{ value| filter1 |filter2}}` 中的 value 其实是 data 中声明数据 的原始类型而不是一个字符串。vue 是把 data 中声明的数据直接双向绑定到 html 页面 而不是把数据转化为字符串后再绑定。因此传入 filter 函数中的并不是一个字符串而是 data 中的原始数据

## 计算属性

- 计算属性也是属性，可以像普通属性那样使用。即可以直接使用文本插值的方式双向绑定到页面中

- 计算属性可以依赖其他计算属性，而且可以依赖多个 Vue 实例的属性

- 计算属性有 getter 和 setter
  - getter：在 computed 中使用计算属性名字直接跟一个 function 是默认使用 getter
  - setter：setter 会在**手动修改计算属性的值**的时候触发，完成一些自定义的操作
  
- 计算属性和方法的区别
  - 计算属性也是属性，可以和普通属性一样使用文本插值的方法直接引入，而方法返回的数据要使用方法的调用才能渲染到页面上（即加括号）
  - 计算属性有缓存，只有当其依赖的属性值改变时才会发生变化；方法无缓存，当页面重新渲染，方法就会重新执行，不重新渲染则不需要重新执行，比如 data 中的一个值发生改变，但是这个值并没有在页面中渲染，那么方法不会重新执行
  
> 注意：页面重新渲染不代表刷新页面，刷新页面相当于销毁当前页面，重新开页面，计算属性当然会变化。可以理解为刷新页面比重新渲染页面弱一些。
>
> 直接像修改普通属性那样在控制台修改计算属性的值，但是 setter 函数里面没有改变其依赖的值，计算属性的值是不会变化的。也就是说计算属性的值只有改变其依赖的值这一种方法改变。

如何选择: -----------使用计算属性还是 methods 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用 计算属性，除非你不希望得到缓存

## Class 与 Style 绑定

在数据绑定中，最常见的两个需求就是元素的样式名称 class 和内联样式 style 的动态绑定，它们也是 HTML 的属性，因此可以使用 v-­bind 指令。我们只需要用 v­-bind 计算出表达式最终的字符串就可以，不过有时候表达式的逻辑较复杂，使用字符串 拼接方法较难阅读和维护，所以 Vue.js 增强了对 class 和 style 的绑定。

比如一个元素的 `v-bind:class="class1 class2...class9"`，如果要删除某个 class，直接操作字符串就会很麻烦，使用增强的方法就会比较简单。

‌对象语法用语用于需要经常动态添加删除一个class。有三种语法形式，即数据对象直接内联绑定在 HTML 标签，绑定 data 中声明的数据对象，绑定计算属性中声明的数据对象

数组法中的 class一般是需要很长时间存在，适用于需要直接更改的 class
‌style 适用于单独操作的某个样式属性

### 一个冲突

关于字符 `-`

中横线 ` -` 是在 JS 中不能用在标识符中，但是常用于 CSS 属性名和选择器，以及 HTML 的属性名和属性值（比如 id class值，就是选择器）。这就会在双向绑定一些数据的时候产生命名冲突，比如 `v-bind` 绑定 class 和 style 时就会经常碰到。这要分两种情况讨论。

1. 绑定 class ，在使用对象语法或者数组语法的时候，选择器习惯使用 `-` 作为分隔符，要用单引号（''）把这个字符串括起来，不然会报错。不能使用驼峰命名代替，驼峰命名表示的是其本来的意思，即 `haveBorder` 就是表示 `haveBorder`，而不是 `have-border` 。
2. 绑定 style，使用对象语法时候，对于带 `-` 的 css 属性名，在双向绑定数据时候可以使用驼峰命名法在 JS 代码中定义， 比如 `fontSize` 代替 `font-size`。

总结：只有 HTML 和 CSS 属性名（自带的东西）可以用驼峰代替，也可以使用单引号包裹。自己定义的选择器名，使用 `-` 要用引号包住，驼峰命名不起作用，这个在 vue 文档中也有体现。

凡是在 HTML 或 CSS 中必须使用 `-` 进行分割的，比如 CSS 属性名，HTML 属性名，组件名，组件属性名（组件名可以认为是 HTML 标签，组件属性名可以认为是 HTML 属性，HTML 是不分大小写的，所以如果分割必须使用 `-`，HTML 中所有的大写字母都会被转换成小写），在 JS 中可以选择使用驼峰命名法进行转换，比如 :

```
fontSize  === font-size
<my-component></my-component> === myComponent:{templete:'xxxx'}
```

在 HTML 中不得使用驼峰，CSS 属性名是规定好的，这两种情况下带 `- ` 的字符串可以在 JS 中使用驼峰命名法代替。

- 一般出现在 HTML 和 CSS 中，在进行数据双向绑定的时候，JS 中通常需要使用这些字符串，JS 中一定可以使用驼峰代替 `-` 分割。使用 `-` 分割时 一般可以使用 `''` 将这个字符串进行包裹，也能正常工作。但是以下两种情况除外：即在 temeplate 中的文本插值中。以及在组件的 data 中使用 this.xxx 引用 props 中的数据时。
- 所以，我们在写代码时候，凡是 JS 代码，一律使用驼峰命名，这不仅符合一般惯例，还能避免出错。

HTML 是不分大小写的，不得使用驼峰命名，必须使用 `-` 进行分割。需要特别注意的时组件名相当于 HTML 标签，父组件给子组件传递数据时的数据名相当于属性名，这两种情况必须使用 `-` 分割。必须使用驼峰不能使用 `-` 的情况，在 temeplate 中的文本插值中。以及在组件的 data 中使用 this.xxx 引用 props 中的数据时。这两种情况下，第一种情况，数据不能成功双向绑定。第二种情况直接报错。所以综上，必须使用 `-` 分割的地方，在 JS 中要使用这个字符串时，尽量使用驼峰命名。

HTML 和 CSS 都不分大小写（HTML 的 id 和 class 的值区分大小写），必须使用 `-` 作为分隔符的，在 JS 中一律可以使用驼峰命名法代替。

## 条件渲染

vue 会尽量复用元素而不是重新渲染元素，如果想重新渲染元素就要使用 key。

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

## 列表渲染

当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 `track-by="$index"`。

这段话的意思就是，vue 的默认行为会复用元素而不是重新渲染元素，使用 `v-for` 渲染的列表的数据项顺序发生移动时，vue 会复用原有的 HTML 元素，只更新发生变化的内容，而不是直接移动 DOM 元素来匹配数据项的顺序。这跟 `v-if` 的特点是一样的。如果想直接更新 DOM 元素，那就要使用 vue 识别节点的通用方法---key。

`key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

看看 官方文档的 替换数组以及[显示过滤/排序后的结果](https://cn.vuejs.org/v2/guide/list.html#显示过滤-排序后的结果)章节 

### 数组更新，过滤与排序

改变数组的一系列方法：

- push() --- 在末尾添加元素
- pop() --- 将数组的最后一个元素移除
- shift() --- 删除数组的第一个元素 
- unshift() --- 在数组的第一个元素位置添加一个元素 
- splice() --- 可以添加或者删除函数—返回删除的元素 三个参数： 
  - 第一个参数 表示开始操作的位置
  - 第二个参数表示：要操作的长度 
  - 第三个为可选参数
- sort() --- 排序 
- reverse() --- 反转

两个数组变动 vue 检测不到: 

1. 直接改变数组的指定项 --- `app.arr[1]='newitem'`
2. 直接设置数组长度  --- `app.arr.length = 10`

解决办法：

1. 改变指定项： Vue.set(app.arr,1,”car”)
2. 改变数组长度  app.arr.splice(1)

非变更方法：即不会对原数组产生影响而是产生一个新数组的方法，比如：`filter()` `concat()` `slice()`

1. 过滤：filter

## 事件处理

1. 如果绑定的方法不需要参数，那么 `v-on:click="funName"`，可以不加括号

2. 如果绑定的方法需要参数，那么正常写法是： `v-on:click="funName(ele)"` 。但是

   1. 如果没有加括号，那么默认传入原生 DOM 事件，即 `ele = event`
   2. 如果只加了个空括号，即 `v-on:click="funName()"`， 那么 默认传入 undefined，即 `ele = undefined`
   3. 如果按要求传入参数，那么方法就正常接受

   [测试demo](http://js.jirengu.com/mebes/1/edit?html,js,output)

有时我们也需要访问原始的 DOM 事件。可以用特殊变量 `$event` 把它传入方法：

```javascript
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) {
      event.preventDefault()
    }
    alert(message)
  }
}
```

尽量直接使用这种做法，而不是使用不加括号默认传入原生 DOM 事件对象，因为所需要的参数并不一定就是 DOM 事件对象，很容易出 BUG。真是希望访问 DOM 事件对象的话，直接按照上面这种正规方式传入就可以了

- 注意这种用法 [内联处理器中的方法](https://cn.vuejs.org/v2/guide/events.html#内联处理器中的方法)
- 注意 [事件修饰符的用法](https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)
  - 官方文档关于 `.self()` 的介绍略显晦涩，通俗的讲就是，只当事件作用在元素本身而非子元素时候方法执行。官方描述是 

> 只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的

## 表单

> 注意：v-model 只有 v-model = "xxx" 的语法，没有其他语法

单个单选框：

1. 使用 v-bind:checked 绑定 data 中的一个值，如果这个值是 true 则选中，否则不是选中状态。使用 v-model 绑定 checked 无效。
2. v-model 用法，和多个单选框相同

单个复选框：

1. 使用 v-bind:checked 或者 v-model:checked 绑定 data 中的一个值，如果这个值是 true 则选中，否则不是选中状态。

v-model 是一个语法糖，不单单是 v-bind:value="xxx" 使用 v-bind 将表单元素的 value 和 vue 实例中的数据绑定那么简单。v-bind 绑定活的属性，但不是数据双向绑定。v-bind 绑定的值会因为 vue 中的数据变化而变化，反之，直接修改 v-bind 绑定的属性值，vue 中的数据并不会发生变化。而 v-model 是数据双向绑定。

v-model 其实是 v-bind 和 @input 事件的结合，即绑定了值又监听了事件

### 单选按钮

单个单选按钮的是否被选中状态只能通过 v-bind 绑定的 checked 属性和 vue 实例中定义的布尔值控制，使用 v-model 绑定一个 vue 中定义的布尔值，无论这个值是 ture 还是 false 不影响单选按钮的选中状态。但是不是说 v-model 就毫无用处了，单选按钮被选中时，使用 v-model 绑定的值会被赋值成为这个单选按钮的 value 值。

这应该跟单选按钮 ridio 的特性有关，因为单选按钮一旦被选中就不能通过再次点击这个按钮取消了，只能通过点击其他同组的按钮来取消被选中的按钮。即如果 vue 中定义的布尔值跟单个单选按钮的选中状态进行了绑定，那么一旦这个值被设置为 ture （直接设置或者是通过选中单选按钮设置）就不能再变为 false 了。上面仅仅是个人猜想，不一定对。单选按钮的特性决定了单选按钮基本不会被单独使用，所以不用纠结。

其实单选按钮的这种机制是符合一般规律的，即 v-model 绑定的是 value 值

### 多选按钮

多选按钮的 v-model 绑定一个数组的时候，v-model 的绑定的值代表选中的 value 的数组，绑定一个布尔值或者字符串的时候，绑定的是按钮是否被选中的布尔值，最终都会被转化为布尔值。其实这个属于另类了，因为其他的表单元素的 v-model 绑定的值都是 value 值，只有多选按钮例外。不管是单个多选按钮还是多个多选按钮效果是一样的。

[测试](http://js.jirengu.com/jevay/1/edit?html,output)

多选按钮上面的特性也是有原因的。如果想多选按钮的 v-model 绑定一个字符串，这个字符串不代表是否被选中的布尔值而是一个 value 的时候，可以在复选框上定义一个 true-value 和 false-value，选中时候 v-model 绑定的值是 true-value，否则是 false-value。 true-value 和 false-value 的这种用法还是要记清楚的

[测试](http://js.jirengu.com/muqax/1/edit)

### 表单总结

对于单选按钮，复选框及选择框的选项，`v-model` 绑定的值通常是静态字符串 。对于复选框可以是布尔值，即当复选框绑定的是一个数组的时候，v-model 绑定的是被选中的值组成的数组。当复选框绑定的是一个静态字符串时，会被转化为布尔值

## 组件

### 全局组件

优点：所有的 Vue 实例都可以用。

缺点：权限太大，容错率降低。跟全局变量有点相似，尽量少用。全局变量，一方面是因为内存原因不使用，另一方面是全局变量所有的函数都可以访问，很容易被不小心修改。

### 标签限制

is：挂载受到 HTML 标签限制而不能使用的模板。

### props 传递数据

1. 在组件中使用 props 来从父亲组件接收参数，注意，在 props 中定义的属性，都可以在组件中直接使用 

2. propps 来自父级，而组件中 data return 的数据就是组件自己的数据，两种情况作用域都是组件本身，可以在 template，computed，methods 中直接使用 
3. props 的值有两种，一种是字符串数组，一种是对象
4. 可以使用 v-­bind 动态绑定父组件来的内容

### 单向数据流

props 传递数据是单向的，也就是说父组件的数据变化会传递给子组件，反之不行。

原因：一个父组件下面有可能有很多子组件，如果一个子组件的某个数据变化会影响到父组件，那么其他使用这个数据的子组件势必也会发生变化，这种变化有可能不是我们所期待的，因此数据的传递必须是单向的。

目的：尽可能地将父子组件解耦，避免子组件无意修改父组件的状态。

直接传入一个数据和使用 v-bind 传入一个数据是有区别的

```javascript
<child-prop :abc="[1,2,3]"></child-prop> // 传入的是一个数组
<child-prop abc="[1,2,3]"></child-prop> // 传入的是一个字符串
```



### 插槽

直接给子组件标签内写入的内容属于父组件的作用域，是不能渲染出来的。想要成功的渲染出来就需要使用 slot。

给子组件标签中间写入一段内容，就是给子组件插入内容

## render 函数

cerateElement() 的第三个参数如果为数组时候 数组里存的就是虚拟的 Dom 节点，即 vnode。cerateElement()函数本身返回的也是虚拟的 dom

vnode 虚拟 dom 节点相对于实际的 dom 节点有一些优势，使用 js 去操作 dom 时候，只要一个 dom 发生变化页面就要重绘。而 vnode 就是一个 js 对像，当 vue 发现某个 vnode 发生变化时侯就会直接更新某个 vnode 而不会直接重绘全部 html 页面，大大提高了效率