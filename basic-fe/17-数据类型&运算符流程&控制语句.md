

# JS-数据类型&运算符流程&控制语句

## 数据类型

一共 6 种，分别是 3 个基本数据类型，2 个特殊类型，1 个复杂类型 （3 + 2 + 1）

- 数值（number）：整数和小数（比如 1 和 3.14）
  - JavaScript 的数字类型和其它语言有所不同，没有整型和浮点数的区别，统一都是 Number 类型，可以表示十进制、八进制、十六进制
  - JavaScript Number 不能表示所有数字，Infinity 表示无穷大
  - NaN 含义是 Not a Number，表示非数字，NaN 和任何值都不相等，包括自己

- 字符串（string）：字符组成的文本（比如 "Hello World"）

- 布尔值（boolean）：`true`（真）和`false`（假）两个特定值

- undefined：表示“未定义”或不存在，即此处目前没有任何值

- null：表示空缺，即此处应该有一个值，但目前为空

- 对象（object）：各种值组成的集合。
  - 又分为普通对象，数组，函数，正则表达式

### typeof 

用来确定一个值到底是什么类型。有 6 种可能的返回值。3 个基本数据类型返回对应的值，undefined 返回 undefined，函数返回 function，其余返回 object。

一个值未声明就使用会报错，一个值声明但是没赋值 或者 没声明 使用 typeof 运算符都不会报错，因此 typeof  可以用来检查一个没有声明的变量，而不报错。

```javascript
v  // ReferenceError: v is not defined
typeof v // "undefined"
```

实际编程中，这个特点通常用在判断语句。

```javascript
// 错误的写法
if (v) { }  // ReferenceError: v is not defined

// 正确的写法
if (typeof v === "undefined") { }
```

### 区分数组和对象

instanceof 可以用来区分数组和对象。下面是和 typeof 的区别

- typeof 是一个一元运算符，运算格式为 `typeof a`，返回一个值的类型，可能返回三种基本类型以及function，undefined，以及 object（arry 为对象 ，null 等特殊值时一律返回 object，这是 typeof 的局限性）。
- instanceof 是一个二元运算符，左边连接需要判断的变量，右边连接预期的类型，如果相符则返回 true，不符则返回 false。instanceof可以判断数组和对象。

```javascript
var o = {};
var a = [];

o instanceof Array // false
a instanceof Array // true
```

## 运算符

在 JavaScript 中运算符通常会根据需要对操作数进行类型转换，乘法操作符**希望**操作数是数字，但是 `"3" * "5"`也是合法的，JavaScript 会自动将其转换为数字计算，返回 15。

### 优先级

单目运算符高于双目运算符，数学运算符高于比较运算符，其次是逻辑运算符，赋值运算符最低。

### 关于逻辑运算符

|| &&

逻辑运算符只有两边都是 bool 值时才一定会返回布尔值，有一个布尔值时有可能返回布尔值，不然要具体情况具体分析。一定要注意这一点，因为印象流很容易觉得布尔值连接的表达式会被数据类型转换为 bool 值。

分析此类问题时候，首先是把运算符两边的值转换为布尔值，然后看哪个表达式最终决定整个表达式的布尔值类型，表达式的结果就是哪个。

```javascript
10 && 6  // 返回6，因为 6 最终决定整个表达式的布尔值。
true || {a:22}  // 返回 true
```

`if()` 括号里面的值一定会被强制转换为bool值

### for-in

for-in 是一种迭代语句，用于枚举对象的属性

```javascript
for(property in object){
    statement
}
```

看个例子

```javascript
for(var prop in window){
    console.log(prop);
}
```

ECMAScript 规定对象中的属性没有顺序，所以 `for-in` 遍历出来的属性的顺序也不是固定的（虽然大部分浏览器是按属性名称排序，我们不能依赖这个）

### 关于 ==

`==` 这个运算符有很多莫名其妙的问题，我们一般认为 `==` 两边的数据进行比较的时候是先进行数据类型的转换再进行比较，但是这个观念也不一定都对，比如以下几个比较就会有一些意想不到的问题出现。

```javascript
Boolean(' ') // 带空格的字符串，转换为布尔值时应该是 true

' ' == false  // 按照一般想法这里是 false，但是结果是 true

' ' == true // 按照一般想法这里是 true，但是结果是 false

if(' ') (console.log(11))  // 成功输出 11 跟 == 结果正好相反

[] == false // 按照一般想法这里是 false，但是结果是 true

[] ==true // 按照一般想法这里是 true，但是结果是 false

Boolean([]) // true
```

### 一些学习资源

1. [知乎前端学习指南](https://zhuanlan.zhihu.com/study-fe), 
2. [GitHub笔试面试题集锦](https://github.com/jirengu/frontend-interview/issues)，
3. [饥人谷课件](http://book.jirengu.com/fe), 
4. [课堂内外一些前端小项目](http://book.jirengu.com/jirengu-inc/js-works/)
5. [前端作品库](http://hungerworks.com/)

1. [阮一峰Javascript教程234](http://javascript.ruanyifeng.com/), 系统权威的 JS 教程，可以作为学习的辅助教材
2. [汤姆大叔的 javascript 翻译系列167](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)， 汤姆大叔翻译的一些优质文章，难度颇高