# 奇葩的 JavaScript

<img src=".\imgs\strange\strange-js.jpg" alt="strange-js" style="zoom: 50%;" />

学过 Java 等语言后写 JS 会有一个明显的感觉，JS 语法非常自由，这种自由在编码时给了我们很大的方便，但同时，也带来了很多困扰。有人说 JS 也是一门充满 "BUG" 的语言，比如各种让人捉摸不透的数据类型自动转换，甚至普通的数学计算，比较或者逻辑运算都会有令人意想不到的结果。其中有一些经常在日常工作中给我们添麻烦，而有些可以给我们带来帮助，让我们大笑起来。

本文旨在总结个人认为的 JS 奇葩之处，不是必须记忆的知识点。没有梳理结构，只是一个简单记录，免得以后碰到反常识的事情时候内心纠结。本文会持续更新。

## 声明变量加不加 var 有区别

- 加 `var` 

声明一个局部变量

- 不加 `var` 

```javascript
function fn(){ 
  a = 1
}

fn()
console.log(a)   // 1，a 是一个全局变量
```

`var` 是变量声明的命令，按照我们一般的理解，直接写 `a = 1` 应该会报错啊，毕竟 `a` 这个变量没有被声明就直接赋值，属于未声明变量就使用。但事实却不是这样，不写 `var` 会声明一个全局的变量，这是我们在编程中应该要避免的，即使真的需要全局变量，也应该在最外层作用域使用 `var` 声明。另外直接在全局作用域写 `a = 1` 不会报错，也算变量声明。

## 变量提升

JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

```javascript
console.log(a);
var a = 1;
```

上面代码首先使用 `console.log` 方法，在控制台（console）显示变量 `a` 的值。这时变量 `a` 还没有声明和赋值，看起来会报错，但是实际上不会。因为存在变量提升，真正运行的是下面的代码。

```javascript
var a;
console.log(a);
a = 1;
```

最后的结果是显示 `undefined`，表示变量 `a` 已声明，但还未赋值

## var 作用域

对于 `var` 命令（即 ES5 ）来说，区块不构成单独的作用域（scope），只有方法作用域。

```JavaScript
{
  var a = 1;
}

a // 1
```

上面代码在区块内部，使用`var`命令声明并赋值了变量 `a`，然后在区块外部，变量`a`依然有效，区块对于`var`命令不构成单独的作用域，与不使用区块的情况没有任何区别。

## 布尔值

相信我们经常看到这么一句话，JavaScript 遇到预期为布尔值的地方（比如 `if` 语句的条件部分），就会将非布尔值的参数自动转换为布尔值。所以我们会很想当然的认为，`&&` 和 `||` 运算符的参数也会被自动转化为布尔值，结果也会返回一个布尔值，其实不是这样。只有以下运算符的结果会一定是布尔值：

- 前置逻辑运算符： `!` (Not)
- 相等运算符：`===`，`!==`，`==`，`!=`
- 比较运算符：`>`，`>=`，`<`，`<=`

关于 `&&` 和 `||` 后面会有介绍。

## 数值

关于数值的不可思议的地方很多，具体可以看阮一峰老师的 JS 教程，这里只列举几个个人认为在实际编码中可能会用到的点，如果按照常规思想，就很可能出错。

学过其他语言的都知道，数值分为浮点数和整数。而且还会细分为 int long float double 等不同的表示方法。但是 JS 中的数值只有一种，那就是 64 位浮点数。所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，`1`与 `1.0` 是相同的，是同一个数。某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数。

```javascript
1 === 1.0 // true
```

浮点数运算又是不精确的，所以会产生很多匪夷所思的结果，具体见文章最上面的图片。

## 数组

空位和undefined的区别

### 数值精度

其实这部分倒不是不合常规，只是比较偏的知识点，平时比较难注意，记录一次方便以后能看到。绝对值小于 2 的 53 次方的整数，即 -2^53^ 到 2^53^，都可以精确表示。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，JavaScript 对 15 位的十进制数都可以精确处理。由上面一段可以知道，JS 某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数。因此，对于整数的位运算（比如移位等操作），JavaScript仅支持 32 位整型数，也即从 -2147483648 到 +2147483647 之间的整数。

这牵扯到 IEEE 754 标准，具体原因去看阮老师教程——[数值](https://wangdoc.com/javascript/types/number.html)。 

```javascript
Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996
```

### 数值范围

JavaScript 能够表示的数值范围的绝对值为 2^1024^ 到 2^-1075^（开区间），还有 0，超出这个范围的数无法表示。这段是个人理解，不一定对。如果一个数大于等于 2 的 1024 次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回`Infinity`。如果一个数绝对值小于等于 2 的 -1075 次方（指数部分最小值 -1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。

```javascript
Math.pow(2, 1024) // Infinity
Math.pow(2, -1075) // 0
```

### 科学计数法

JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如`35`（十进制）和`0xFF`（十六进制）。也可以采用科学计数法表示。

以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

**（1）小数点前的数字多于21位。**

```javascript
1234567890123456789012
// 1.2345678901234568e+21

123456789012345678901
// 123456789012345680000
```

**（2）小数点后的零多于5个。**

```javascript
// 小数点后紧跟5个以上的零，
// 就自动转为科学计数法
0.0000003 // 3e-7

// 否则，就保持原来的字面形式
0.000003 // 0.000003
```

### 八进制

八进制：有前缀 `0o` 或 `0O` 的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。但是前导 0 表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法。比如下面：

```javascript
0888 // 888
0777 // 511
```

### NaN 和 Infinity

JS 中单纯的数学运算几乎没有可能抛出错误。因为有这两个值。比如我们都知道 0 是不能作为除数的，在其它语言会报错，在 JS 中，非 0 数除以 0 得到 ±Infinity。0 除以 0 得到 Nan。

`Infinity`与`NaN`比较，总是返回`false`。

```javascript
Infinity > NaN // false
-Infinity > NaN // false

Infinity < NaN // false
-Infinity < NaN // false
```

### parseInt()

`parseInt`方法用于将字符串转为整数，返回值只有两种可能，要么是一个十进制整数，要么是`NaN`。如果字符串以`0x`或`0X`开头，`parseInt`会将其按照十六进制数解析。

对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。

```javascript
parseInt(1000000000000000000000.5) // 1
// 等同于
parseInt('1e+21') // 1

parseInt(0.0000008) // 8
// 等同于
parseInt('8e-7') // 8
```

## 函数的参数

在 JS 中，函数也是一种数据类型，是一个对象。

JS 函数的定义和调用并没有那么严格，和 Java 等语言有很大不同。 JS 函数的参数本质是一个类数组对象 arguments[^1]，调用函数传入的实参都会放入 arguments 中，即 arguments [0]，arguments [1]......

### 函数定义

函数定义时，设置形参可以让代码更好懂。形参实际上可以看做是 arguments [0]，arguments [1] 的代号。形参可以多定义，即比函数体中使用到的多，但是一定不能少定义，少定义会报错 `Uncaught ReferenceError: xxx is not defined`。

### 函数调用

JS 函数在定义的时候可以传入形参，一般情况下，调用函数时也应该传入相应数量的实参。但是，函数调用时，即使传入的实参个数和函数定义时候的形参个数不一致，也不会报错。参数传入多了函数会正常运行，少了可能会出现非预期的结果。

造成以上现象的原因是：在函数内部,可以使用 `arguments` 对象获取到该函数的所有传入参数，即函数在调用的时候使用的是 arguments [0]，arguments [1]......的值。因此，当调用函数时多传入了几个参数，只不过是 arguments  中多了几个多余的值，函数实际运行需要的值都存在，所以函数会正常使用 arguments [0]，arguments [1]......，函数运行正常。少传入的值为 undefined，可能会与实际期待结果不符合。

### 与 Java 的区别

JS 和 Java 很不同。主要表现在：

- Java 定义时参数不同（参数个数或类型不同）的话，即使函数名字相同那也不是同一个函数（重载），Java 定义时候的形参和调用时候的实参一定要一致（个数，数据类型，位置）。

- JS 函数的参数可以是一个函数，但 Java 不行，因为 Java 的函数不是一个数据类型。

- JS 可以嵌套定义函数，Java 不可以。

以上分析可以看出 JS 不能重载，JS 只要函数名字相同就是同一个函数。Java 要方法签名（方法名 + 参数列表）一致才是同一个方法。

arguments 是 一个类数组对象。首先，我们可以像数组一样通过下标的方式获取 arguments的值，而且具有length这个属性，但它本身又不是一个数组，没有数组的特性，所以叫做类数组对象。



## 关于 JSON

混乱的参数和返回值

```javascript
var a = JSON.stringify('abc')  // a = ""abc""
JSON.parse(""abc"")  // 报错 VM256:1 Uncaught SyntaxError: missing ) after argument list
JSON.parse(a)  // "abc"
JSON.parse('"abc"') 
JSON.parse("'abc'") 

/*
uncaught SyntaxError: Unexpected token ' in JSON at position 0
    at JSON.parse (<anonymous>)
    at <anonymous>:1:6
 */
```

## Array

### 长度自由定义

JavaScript 的数组有点超出以往知识认知。一般对于 C 或者 Java，数组一旦定义，长度就不能改变。但是 JavaScript 的数组非常自由，可以随意改变，比如下面：

```javascript
var a = new Array(1,2,3);
console.log(a.length);  // 3
a[100] = 100;
console.log(a.length); //101。直接把数组长度从 3 变为 101。
console.log(a[3]); //undefined
console.log(a[99]); //undefined
console.log(a[100]); 100
```

上面的例子中，虽然直接对 `a[100]` 赋值不会影响 `a[4]` 或 `a[99]`，但数组的长度却受到影响，数组 `length` 属性等于数组中最大的 `index+1`，数组的 length 属性同样是个可写的属性，当强制把数组的 length 属性值设置为小于等于最大 index 值时，数组会自动删除 index 大于等于 length 的数据，在刚才代码中追加几句

```javascript
a.length = 2
console.log(a);//[1,2]
```

这时候会发现 `a[2]` 和 `a[100]` 被自动删除了，同理，如果把 length 设置为大于最大 index+1 的值的时候，数组也会自动扩张，但是不会为数组添加新元素，只是在尾部追加空空间

```javascript
a.length=5;
console.log(a); //[1,2]，后面没有3个undefined    
```

### 没有索引越界异常

使用索引法访问 JavaScript 里的元素时，不会出现索引越界的情况，数组的索引可以不是连续的，访问 index 不存在的元素的时候返回 `undefined`。

```javascript
var a = new Array(1,2,3);
console.log(a[100]);     // undefined
```

## 数据类型转化

JS 的自动类型转换就一个字，迷。。。反正我是捉摸不透。比如"3" * "5"，不但不会报错，反而得到结果为15。